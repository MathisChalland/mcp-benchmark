// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: npx tsx src/benchmark/tools/generate-tools-api-def.ts

const INTERFACE_DEFINITIONS = `
interface Customer {
  id: string;
  name: string;
  email: string;
  address: string;
  createdAt: string; // ISO date string
}

interface Product {
  id: string;
  name: string;
  description: string;
  price: number; // Price in Cent
  stock: number;
  createdAt: string; // ISO date string
}

interface Order {
  id: string;
  customerId: string;
  orderDate: string; // ISO date string
  total: number; // Total price in Cent
  status: string;
}
`;

const TOOL_DEFINITIONS: Record<string, string> = {
  get_customer: `/**
 * Retrieves a customer by their ID or Email from the database
 */
declare function get_customer({ customerId, email, }: { customerId?: string; email?: string; }): Promise<Customer>;`,
  search_customers: `/**
 * Search and filter customers with flexible criteria
 */
declare function search_customers({ searchTerm, minOrders, maxOrders, minTotalSpent, maxTotalSpent, registeredAfter, registeredBefore, sortBy = "name", sortOrder = "asc", limit = 20, offset = 0, }: { searchTerm?: string; minOrders?: number; maxOrders?: number; minTotalSpent?: number; maxTotalSpent?: number; registeredAfter?: string; registeredBefore?: string; sortBy?: "name" | "email" | "createdAt" | "orderCount" | "totalSpent"; sortOrder?: "asc" | "desc"; limit?: number /*max 100*/; offset?: number; }): Promise<{
  customers: Array<
    Customer & {
      orderCount: number;
      totalSpent: number;
    }
  >;
  hasMore: boolean;
}>;`,
  get_customer_orders: `/**
 * Retrieves all orders for a specific customer with optional filters
 */
declare function get_customer_orders({ customerId, startDate, endDate, status, }: { customerId: string; startDate?: string; endDate?: string; status?: string; }): Promise<Order[]>;`,
  get_order_details: `/**
 * Get detailed information about a specific order
 * @param orderId - The ID of the order to retrieve
 */
declare function get_order_details({ orderId, }: { orderId: string; }): Promise<
  Omit<Order, "customerId"> & {
    customer: { id: string; name: string; email: string };
    items: Array<{
      id: string;
      productId: string;
      productName: string;
      quantity: number;
      price: number;
    }>;
  }
>;`,
  get_revenue_analysis: `/**
 * Get comprehensive revenue metrics with time-based grouping
 */
declare function get_revenue_analysis({ startDate, endDate, groupBy = "month", }: { startDate?: string; endDate?: string; groupBy?: "day" | "week" | "month" | "year"; }): Promise<{
  summary: {
    totalRevenue: number;
    totalOrders: number;
    averageOrderValue: number;
    periodCount: number;
  };
  periods: Array<{
    period: string;
    revenue: number;
    orderCount: number;
    averageOrderValue: number;
  }>;
}>;`,
  search_orders: `/**
 * Search and filter orders with flexible criteria
 */
declare function search_orders({ startDate, endDate, status, minTotal, maxTotal, customerId, sortBy = "orderDate", sortOrder = "desc", limit = 20, offset = 0, }: { startDate?: string; endDate?: string; status?: string; minTotal?: number; maxTotal?: number; customerId?: number; sortBy?: "orderDate" | "total" | "status"; sortOrder?: "asc" | "desc"; limit?: number /* max 100 */; offset?: number; }): Promise<{
  orders: Array<{
    id: string;
    customerId: string;
    customerName: string;
    customerEmail: string;
    orderDate: string;
    status: string;
    total: number;
    itemCount: number;
  }>;
  hasMore: boolean;
}>;`,
  get_product: `/**
 * Retrieves a product by its ID from the database
 */
declare function get_product({ productId, }: { productId: string; }): Promise<Product>;`,
  get_product_stats: `/**
 * Get product sales statistics
 */
declare function get_product_stats({ productId, startDate, endDate, limit = 20, offset = 0, sortBy = "totalRevenue", sortOrder = "desc", }: { productId?: string; startDate?: string; endDate?: string; limit?: number /* max 100 */; offset?: number; sortBy?: | "totalRevenue" | "totalQuantitySold" | "orderCount" | "averageQuantityPerOrder" | "productName"; sortOrder?: "asc" | "desc"; }): Promise<
  Array<{
    averageQuantityPerOrder: number;
    productId: string;
    productName: string;
    totalQuantitySold: number;
    totalRevenue: number;
    orderCount: number;
  }>
>;`,
  search_products: `/**
 * Search and filter products with flexible criteria
 */
declare function search_products({ searchTerm, minPrice, maxPrice, minStock, maxStock, sortBy = "name", sortOrder = "asc", limit = 20, offset = 0, }: { searchTerm?: string; minPrice?: number; maxPrice?: number; minStock?: number; maxStock?: number; sortBy?: "name" | "price" | "stock" | "createdAt"; sortOrder?: "asc" | "desc"; limit?: number /* max 100 */; offset?: number; }): Promise<{
  products: Product[];
  hasMore: boolean;
}>;`,
  get_inventory_status: `/**
 * Get comprehensive inventory status and alerts
 */
declare function get_inventory_status({ lowStockThreshold = 10, includeOutOfStock = true, includeLowStock = true, includeInStock = false, limit, sortBy = "stock", sortOrder = "asc", }: { lowStockThreshold?: number; includeOutOfStock?: boolean; includeLowStock?: boolean; includeInStock?: boolean; limit?: number; sortBy?: "name" | "stock" | "price"; sortOrder?: "asc" | "desc"; }): Promise<{
  summary: {
    totalProducts: number;
    outOfStockCount: number;
    lowStockCount: number;
    inStockCount: number;
    totalStockValue: number;
  };
  outOfStockProductIds?: string[];
  lowStockProductIds?: string[];
  inStockProductIds?: string[];
}>;`,
};

export const AVAILABLE_TOOLS = [
  "get_customer",
  "search_customers",
  "get_customer_orders",
  "get_order_details",
  "get_revenue_analysis",
  "search_orders",
  "get_product",
  "get_product_stats",
  "search_products",
  "get_inventory_status",
] as const;

export type ToolName = (typeof AVAILABLE_TOOLS)[number];

/**
 * Returns the complete API definition for all available tools
 */
export function getToolsAPI(): string {
  const allDeclarations = Object.values(TOOL_DEFINITIONS).join("\n\n");
  return `${INTERFACE_DEFINITIONS}

${allDeclarations}`;
}

/**
 * Returns the API definition for the selected tools only
 * @param tools - Array of tool names to include
 */
export function getSelectedToolsAPI(tools: string[]): string {
  const selectedDeclarations = tools
    .filter((tool) => tool in TOOL_DEFINITIONS)
    .map((tool) => TOOL_DEFINITIONS[tool])
    .join("\n\n");

  if (!selectedDeclarations) {
    throw new Error(
      `No valid tools found. Available tools: ${AVAILABLE_TOOLS.join(", ")}`,
    );
  }

  return `${INTERFACE_DEFINITIONS}

${selectedDeclarations}`;
}
