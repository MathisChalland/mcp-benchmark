import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface FunctionInfo {
  name: string;
  signature: string;
  jsdoc: string | null;
}

const TOOL_FILES = [
  "customer/get_customer.ts",
  "customer/search_customers.ts",
  "order/get_customer_orders.ts",
  "order/get_order_details.ts",
  "order/get_revenue_analysis.ts",
  "order/search_orders.ts",
  "product/get_product.ts",
  "product/get_product_stats.ts",
  "product/search_products.ts",
  "product/get_inventory_status.ts",
];

function extractFunctionInfo(filePath: string): FunctionInfo | null {
  const content = fs.readFileSync(filePath, "utf-8");

  const funcMatch = content.match(
    /export async function (\w+)\s*\(([\s\S]*?)\)\s*(?::\s*(Promise<[\s\S]*?>))?\s*{/,
  );

  if (!funcMatch) {
    console.warn(`No function signature found in ${filePath}`);
    return null;
  }

  const [, name, params, explicitReturnType] = funcMatch;

  const jsdocMatch = content.match(
    /\/\*\*([\s\S]*?)\*\/\s*export async function/,
  );

  let jsdoc: string | null = null;
  if (jsdocMatch?.[1]) {
    const jsdocRaw = jsdocMatch[1];
    const jsdocLines = jsdocRaw
      .split("\n")
      .map((line) => line.trim().replace(/^\*\s?/, ""))
      .filter((line) => line.length > 0);
    jsdoc = jsdocLines.join("\n * ");
  }

  const returnType = explicitReturnType ?? "Promise<any>";

  const cleanParams = (params ?? "")
    .split("\n")
    .map((line) => line.trim())
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();

  return {
    name: name!,
    signature: `${name}(${cleanParams}): ${returnType}`,
    jsdoc,
  };
}

function loadInterfaceDefinitions(typesFilePath: string): string {
  const content = fs.readFileSync(typesFilePath, "utf-8");

  const definitions: string[] = [];

  const interfaceRegex = /(?:export\s+)?interface\s+\w+\s*{[\s\S]*?^}/gm;
  const interfaces = content.match(interfaceRegex) || [];
  definitions.push(...interfaces.map((i) => i.replace(/^export\s+/, "")));

  const typeRegex = /(?:export\s+)?type\s+\w+\s*=[\s\S]*?;/gm;
  const types = content.match(typeRegex) || [];
  definitions.push(...types.map((t) => t.replace(/^export\s+/, "")));

  return definitions.join("\n\n");
}

function generateToolsApiDefFile(): void {
  const toolsDir = path.join(__dirname);
  const typesFilePath = path.join(toolsDir, "types.ts");
  const outputFilePath = path.join(toolsDir, "tools-api-def.ts");

  const functions = TOOL_FILES.map((file) => {
    const info = extractFunctionInfo(path.join(toolsDir, file));
    if (!info) {
      console.error(`Failed to extract function info from ${file}`);
    }
    return info;
  }).filter((f): f is FunctionInfo => f !== null);

  if (functions.length === 0) {
    throw new Error("No functions extracted!");
  }

  const interfaceDefinitions = loadInterfaceDefinitions(typesFilePath);

  // Build the tool definitions map
  const toolDefinitions: Record<string, string> = {};
  for (const f of functions) {
    let declaration: string;
    if (f.jsdoc) {
      declaration = `/**\n * ${f.jsdoc}\n */\ndeclare function ${f.signature};`;
    } else {
      declaration = `declare function ${f.signature};`;
    }
    toolDefinitions[f.name] = declaration;
  }

  const toolNames = functions.map((f) => f.name);

  // Generate the output file content
  const outputContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: npx tsx src/benchmark/tools/generate-tools-api-def.ts

const INTERFACE_DEFINITIONS = \`
${interfaceDefinitions}
\`;

const TOOL_DEFINITIONS: Record<string, string> = {
${Object.entries(toolDefinitions)
  .map(
    ([name, declaration]) =>
      `  "${name}": \`${declaration.replace(/`/g, "\\`")}\`,`,
  )
  .join("\n")}
};

export const AVAILABLE_TOOLS = [
${toolNames.map((name) => `  "${name}",`).join("\n")}
] as const;

export type ToolName = (typeof AVAILABLE_TOOLS)[number];

/**
 * Returns the complete API definition for all available tools
 */
export function getToolsAPI(): string {
  const allDeclarations = Object.values(TOOL_DEFINITIONS).join("\\n\\n");
  return \`\${INTERFACE_DEFINITIONS}

\${allDeclarations}\`;
}

/**
 * Returns the API definition for the selected tools only
 * @param tools - Array of tool names to include
 */
export function getSelectedToolsAPI(tools: string[]): string {
  const selectedDeclarations = tools
    .filter((tool) => tool in TOOL_DEFINITIONS)
    .map((tool) => TOOL_DEFINITIONS[tool])
    .join("\\n\\n");

  if (!selectedDeclarations) {
    throw new Error(\`No valid tools found. Available tools: \${AVAILABLE_TOOLS.join(", ")}\`);
  }

  return \`\${INTERFACE_DEFINITIONS}

\${selectedDeclarations}\`;
}
`;

  fs.writeFileSync(outputFilePath, outputContent, "utf-8");
  console.log(`âœ… Generated tools-api-def.ts with ${functions.length} tools:`);
  console.log(toolNames.map((n) => `   - ${n}`).join("\n"));
}

// Run the generator when this file is executed directly
const isMainModule =
  import.meta.url === `file://${process.argv[1]}` ||
  process.argv[1]?.endsWith("generate-tools-api-def.ts");

if (isMainModule) {
  generateToolsApiDefFile();
}
