import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TOOLS_DIR = path.join(__dirname, "../tools");
const TYPES_FILE = path.join(__dirname, "types.ts");
const OUTPUT_FILE = path.join(__dirname, "tools-api-def.ts");

interface FunctionInfo {
  name: string;
  signature: string;
  jsdoc: string | null;
}

function findToolFiles(dir: string, baseDir: string = dir): string[] {
  const files: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...findToolFiles(fullPath, baseDir));
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      files.push(path.relative(baseDir, fullPath));
    }
  }

  return files.sort();
}

function extractFunctionInfo(filePath: string): FunctionInfo | null {
  const content = fs.readFileSync(filePath, "utf-8");

  const funcMatch =
    /export async function (\w+)\s*\(([\s\S]*?)\)\s*(?::\s*(Promise<[\s\S]*?>))?\s*{/.exec(
      content,
    );

  if (!funcMatch) {
    console.warn(`No function signature found in ${filePath}`);
    return null;
  }

  const [, name, params, explicitReturnType] = funcMatch;

  const jsdocMatch = /\/\*\*([\s\S]*?)\*\/\s*export async function/.exec(
    content,
  );

  let jsdoc: string | null = null;
  if (jsdocMatch?.[1]) {
    const jsdocRaw = jsdocMatch[1];
    const jsdocLines = jsdocRaw
      .split("\n")
      .map((line) => line.trim().replace(/^\*\s?/, ""))
      .filter((line) => line.length > 0);
    jsdoc = jsdocLines.join("\n * ");
  }

  const returnType = explicitReturnType ?? "Promise<any>";

  const cleanParams = params ?? "";

  return {
    name: name!,
    signature: `${name}(${cleanParams}): ${returnType}`,
    jsdoc,
  };
}

function loadInterfaceDefinitions(
  typesFilePath: string,
): Record<string, string> {
  const content = fs.readFileSync(typesFilePath, "utf-8");

  const definitions: Record<string, string> = {};

  const interfaceRegex = /(?:export\s+)?interface\s+(\w+)\s*{[\s\S]*?^}/gm;
  let match;
  while ((match = interfaceRegex.exec(content)) !== null) {
    const name = match[1]!;
    const declaration = match[0].replace(/^export\s+/, "");
    definitions[name] = declaration;
  }

  const typeRegex = /(?:export\s+)?type\s+(\w+)\s*=[\s\S]*?;/gm;
  while ((match = typeRegex.exec(content)) !== null) {
    const name = match[1]!;
    const declaration = match[0].replace(/^export\s+/, "");
    definitions[name] = declaration;
  }

  return definitions;
}

function generateToolsApiDefFile(): void {
  const toolFiles = findToolFiles(TOOLS_DIR);

  const functions = toolFiles
    .map((file) => {
      const info = extractFunctionInfo(path.join(TOOLS_DIR, file));
      if (!info) {
        console.error(`Failed to extract function info from ${file}`);
      }
      return info;
    })
    .filter((f): f is FunctionInfo => f !== null);

  if (functions.length === 0) {
    throw new Error("No functions extracted!");
  }

  const interfaceDefinitions = loadInterfaceDefinitions(TYPES_FILE);

  const toolDefinitions: Record<string, string> = {};
  for (const f of functions) {
    let declaration: string;
    if (f.jsdoc) {
      declaration = `/**\n * ${f.jsdoc}\n */\ndeclare function ${f.signature};`;
    } else {
      declaration = `declare function ${f.signature};`;
    }
    toolDefinitions[f.name] = declaration;
  }

  const toolNames = functions.map((f) => f.name);

  const outputContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: npx tsx src/benchmark/code-approach/generate-tools-api-def.ts

export const INTERFACE_DEFINITIONS: Record<string, string> = {
${Object.entries(interfaceDefinitions)
  .map(
    ([name, declaration]) =>
      `  ${name}: \`${declaration.replace(/`/g, "\\`")}\`,`,
  )
  .join("\n")}
};

export const TOOL_DEFINITIONS: Record<string, string> = {
${Object.entries(toolDefinitions)
  .map(
    ([name, declaration]) =>
      `  ${name}: \`${declaration.replace(/`/g, "\\`")}\`,`,
  )
  .join("\n")}
};

export const AVAILABLE_TOOLS = [
${toolNames.map((name) => `  "${name}",`).join("\n")}
] as const;

export type ToolName = (typeof AVAILABLE_TOOLS)[number];
`;

  fs.writeFileSync(OUTPUT_FILE, outputContent, "utf-8");
  console.log(`âœ… Generated tools-api-def.ts with ${functions.length} tools:`);
  console.log(toolNames.map((n) => `   - ${n}`).join("\n"));
}

// Run the generator when this file is executed directly
const isMainModule =
  import.meta.url === `file://${process.argv[1]}` ||
  process.argv[1]?.endsWith("generate-tools-api-def.ts");

if (isMainModule) {
  generateToolsApiDefFile();
}
